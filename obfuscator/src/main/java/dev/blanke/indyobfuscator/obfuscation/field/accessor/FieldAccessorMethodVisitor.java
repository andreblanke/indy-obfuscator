package dev.blanke.indyobfuscator.obfuscation.field.accessor;

import java.util.Objects;

import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;
import org.objectweb.asm.commons.GeneratorAdapter;

import static org.objectweb.asm.Opcodes.*;

/**
 * Denotes a {@link MethodVisitor} generating the code for a synthetic field accessor method, i.e. either a getter
 * (see {@link FieldGetterMethodVisitor}) or a setter (see {@link FieldSetterMethodVisitor}).
 * <p>
 * Subclasses override the {@link #visitCode()} method to prepare the stack according to the field access being
 * emulated.
 */
abstract sealed class FieldAccessorMethodVisitor extends GeneratorAdapter {

    /**
     * The field access which should be emulated using the code generated by this class.
     */
    protected final FieldAccess fieldAccess;

    protected FieldAccessorMethodVisitor(final int api, final MethodVisitor methodVisitor,
                                         final FieldAccess fieldAccess) {
        super(api, methodVisitor, fieldAccess.syntheticAccessorInvocationAccess(),
            fieldAccess.syntheticAccessorInvocation().name(),
            fieldAccess.syntheticAccessorInvocation().descriptor());
        this.fieldAccess = Objects.requireNonNull(fieldAccess);
    }

    /**
     * Visits instructions which are common to both kinds of accessor methods, i.e. delegating to the original field
     * instruction and returning.
     *
     * @implNote Subclasses are expected to prepare the stack accordingly and to invoke this method at the end of their
     *           {@code visitCode()} implementation.
     */
    @Override
    public void visitCode() {
        final var identifier = fieldAccess.fieldIdentifier();
        visitFieldInsn(fieldAccess.opcode(), identifier.owner(), identifier.name(), identifier.descriptor());
        returnValue();
    }

    /**
     * Visits the maximum stack size and maximum number of local variables of the method.
     * <p>
     * Both values depend on whether the {@link #fieldAccess} is done to an instance member (in which case an
     * additional stack and local variable slot will be occupied by the instance reference) and whether a field is being
     * put (in which case an additional local variable slot will be occupied by the method argument).
     *
     * @param maxStack Maximum stack size of the method.
     *
     * @param maxLocals Maximum number of local variables for the method.
     */
    @Override
    public void visitMaxs(int maxStack, int maxLocals) {
        final var isVirtual =
            ((fieldAccess.opcode() == PUTFIELD) || (fieldAccess.opcode() == GETFIELD));
        final var isSetter =
            ((fieldAccess.opcode() == PUTFIELD) || (fieldAccess.opcode() == PUTSTATIC));

        /*
         * The field accessor takes up at least one stack slot for the setter argument/get* return value (two in case
         * of a double or long), plus an additional slot for the object reference on which the (get|put)field
         * instruction is being executed unless the accessor being generated is static.
         */
        final int valueSize = Type.getType(fieldAccess.fieldIdentifier().descriptor()).getSize();
        maxStack = Math.max(maxStack, valueSize + (isVirtual ? 1 : 0));

        /*
         * The field accessor uses one local variable slot for 'this' unless the field this accessor belongs to is
         * static, plus an additional slot for a setter argument.
         */
        maxLocals = Math.max(maxLocals, (isVirtual ? 1 : 0) + (isSetter ? 1 : 0));

        super.visitMaxs(maxStack, maxLocals);
    }

    /**
     * A {@link MethodVisitor} which generates code to prepare the stack for a {@link org.objectweb.asm.Opcodes#GETFIELD}
     * or a {@link org.objectweb.asm.Opcodes#GETSTATIC} field access and for performing the field access.
     */
    static final class FieldGetterMethodVisitor extends FieldAccessorMethodVisitor {

        FieldGetterMethodVisitor(final int api, final MethodVisitor methodVisitor,
                                 final FieldAccess fieldAccessor) {
            super(api, methodVisitor, fieldAccessor);
        }

        @Override
        public void visitCode() {
            // Push instance reference in case the field is an instance member.
            if (fieldAccess.opcode() == GETFIELD)
                loadArg(0);
            // Invoke original field instruction and return.
            super.visitCode();
        }
    }

    /**
     * A {@link MethodVisitor} which generates code to prepare the stack for a {@link org.objectweb.asm.Opcodes#PUTFIELD}
     * or a {@link org.objectweb.asm.Opcodes#PUTSTATIC} field access and for performing the field access.
     */
    static final class FieldSetterMethodVisitor extends FieldAccessorMethodVisitor {

        FieldSetterMethodVisitor(final int api, final MethodVisitor methodVisitor,
                                 final FieldAccess fieldAccessor) {
            super(api, methodVisitor, fieldAccessor);
        }

        @Override
        public void visitCode() {
            // Push field value or instance reference onto the stack.
            loadArg(0);
            // Push field value in case the field is an instance member.
            if (fieldAccess.opcode() == PUTFIELD)
                loadArg(1);
            // Invoke original field instruction and return.
            super.visitCode();
        }
    }
}
